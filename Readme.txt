																							ΑΝΑΠΤΥΞΗ ΛΟΓΙΣΜΙΚΟΥ ΑΣΚΗΣΗ 3η

Ονομα			ΕΠΙΘΕΤΟ			Α.Μ.

ΗΛΙΑΣ			ΒΕΡΓΟΣ			1115201400266
ΚΩΣΤΑΝΤΙΝΟΣ 	ΠΛΕΥΡΗΣ			1115201400162



Προγραμματιστικο Περιβαλλον :LINUX 
Eντολη Μεταγλωτισσης: make
Στο Makefile κανουμε 2 μεταγλωτισσεις,1 για το unit test και μια για το κανονικο προγραμμα.
Για το Unit Testing χρησιμοποιουμε το framework CUnit.Τεσταρουμε στις συναρτησεις static insert,dynamic insert,delete(ΓΙΑ ΤΟ DYNAMIC MOΝΟ ΓΙΑΤΙ ΤΟ ΣΤΑΤΙΚΟ ΔΕΝ ΕΧΕΙ ΔΙΑΓΡΑΦΕΣ), static search,dynamic search,insertion_sort,binary_search.
Για την εγκατασταση της βιβλιοθηκης θα χρειαστει να εκτελεσετε την εντολη :
	sudo apt-get install libcunit1 libcunit1-doc libcunit1-dev
Βεβαια εχουμε συμπεριλαβει και την βιβλιοθηκη μεσα για παν ενδεχομενο.
./exe 		   		-->Unit Test
./ngrams arg1 arg2  -->main programm

																TΕΛΙΚΗ ΑΝΑΦΟΡΑ ΕΡΓΑΣΙΑΣ ΣΤΗΝ ΑΝΑΠΤΥΞΗ ΛΟΓΙΣΜΙΚΟΥ ΓΙΑ ΠΛΗΡΟΦΟΡΙΑΚΑ ΣΥΣΤΗΜΑΤΑ

Tο πρωτο κομματι της ασκησης αφορα την δημιουργια του Τrie καθως και την εισαγωγη ,διαγραφη και αναζητηση σε αυτο.Σε αυτο το κομματι υλοποιησαμε εισαγωγη και αναζητηση με αναδρομικες συναρτησεις ,που ειχε ως αποτελεσμα αυξηση του χρονου.Ακομα, ειχαμε ενα δυναμικο string για την λεξη μεσα σε καθε κομβο και δεν ειχαμε κανενα στατικο σε περιπτωση που το string ηταν μικρο.Και αυτο ειχε ως αποτελεσμα μια πολυ μικρη αυξηση του χρονου.Κατι ακομα που μας απασχολησε ηταν ποια συναρτηση αναζητησης θα χρησιμοποιουσαμε.Αρχικα δοκιμασαμε την σειριακη αναζητηση ομως απο πλευρας χρονου ηταν πολυ σπαταλη λογω της πολυπλοκοτητας της .Στην συνεχεια δοκιμασαμε την δυαδικη αναζητηση .Ο χρονος ηταν καλος ,οχι ομως ικανοποιητικος.Γιαυτο σκεφτηκαμε να χρησιμοποιησουμε την binary insertion sort που φαινοταν να ηταν καλυτερη.Ομως δεν ειδαμε καποια διαφορα ,ισα ισα που ειχαμε μια μικρη αυξηση στον χρονο,οποτε και την αλλαξαμε και καταληξαμε στην binary search.Παρομοια διλληματα ειχαμε και με την ταξινομηση μιας και εδω ειχαμε πολλες επιλογες.Ξεκινησαμε με φυσαλιδα ,ο χρονος ηταν κατα μια εννοια καλος .Δοκιμασαμε διαφορες ταξινομησεις χωρις καποια αξιολογη διαφορα.Γιαυτο  αφησαμε την φυσαλιδα για λιγο.Ομως στο τελος θελωντας να βελτιωσουμε αρκετα τον χρονο μας κατι επρεπε να αλλαξουμε,και γιαυτο σκεφτηκαμε την insertion sort που ηταν οτι καλυτερο για πινακες που ειναι σχεδον ταξινομημενοι οπως στην περιπτωση μας.Και ετσι αφησαμε την insertion sort.





Καποιοι ενδεικτικοι χρονοι για τα παραπανω παρουσιαζονται στον παρακατω πινακα:

	 		
	  		
------------|-------|-------|-------|-------|-------|
   XΡΟΝΟΙ	|30.4sec|		|		|		|		|
------------|-------|-------|-------|-------|-------|
αναδρομικες |		|		|		|		|		|
συναρτησεις |	+	|	+	|	+	|	+	|		|
			|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|
			|		|		|		|		|		|
δυναμικα 	|	+	|	+	|	+	|	+	|		|
strings		|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|
φυσαλιδα	|		|	+	|	+	|		|		|
------------|-------|-------|-------|-------|-------|
σειριακη 	|		|		|		|		|		|
αναζητηση	|		|		|	+	|	+	|		|
			|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|
insertion	|		|		|		|		|		|
sort		|	+	|		|		|	+	|		|
			|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|
binary 		|		|		|		|		|		|
search		|	+	|	+	|		|		|		|
			|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|





Το δευτερο μερος ξεκινησε κανοντας τις αλλαγες που μας ειπωθηκαν.Δηλαδη αλλαξαμε τις λεξεις μεσα στα Trie nodes να ειναι στατικα αν το μηκος της λεξης ειναι μικροτερο απο 50 και δυναμικο αν ειναι μεγαλυτερο του 50.Οπως ειπαμε παραπανω δεν παρατηρηθηκε καποια αισθητη αλλαγη .Το ιδιο συνεβη και με την αλλαγη των συναρτησεων απο αναδρομικες σε επαναληπτικες.Η διαφορα σε χρονο και μνημη ηταν σχεδον μηδαμινη.Κατι αλλο που μας ειπωθηκε ηταν να αλλαξουμε την insertion sort και να χρησιμοποιησουμε memmove για καλυτερη προσπελαση της μνημης και επομενως καλυτερο χρονο.Το καναμε και το αποτελεσμα ηταν καποια μικρη διαφορα της ταξεως των _____ δευτερολεπτων στo small dataset και ____ δευτερολεπτων στο medium dataset.Aφου καναμε τις απαραιτητες αλλαγες προχωρησαμε στην υλοποιηση του 2ου μερους της ασκησης.Σε αυτο το μερος ξεκινησαμε να φτιαχνουμε το bloom filter το οποιο βασιζεται πανω σε ενα char* του οποιου καθε θεση περιεχει 8 bits μιας και char= 1byte = 8 bits.Αρχικοποιουμε τον πινακα αυτο με 0 κανοντας την πραξη bitwise AND (&0) με καθε θεση του πινακα.Στην συνεχεια οταν ειναι να ελενξουμε αν υπαρχει μεσα στον πινακα ενα ngram ελενχουμε την τιμη της θεσης του πινακα που προκυπτει απο την hash function με την θεση του bit που προκυπτει και αυτη απο την hash function και κανουμε τον ελενχο ((array[position]>>bit_position)&1).Aν βγει 0 η συνθηκη αυτη τοτε σημαινει οτι δεν υπαρχει αλλιως υπαρχει αν βγει 1.Η συνθηκη αυτη προκυπτει και απο τον τροπο με τον οποιο βαζουμε ενα στοιχειο μεσα στον πινακα.Αυτο γινεται παιρνωντας το 1 που θελουμε να βαλουμε στην θεση του bit ολισθαινοντας το κατα bit_position θεσεις αριστερα.Ετσι ο πινακα παιρνει μια τιμη που ειναι απο (-128,128) και συμβολιζει την λεξη που μπηκε.Αυτα οσο αναφορα την υλοποιηση του bloom filter.Η υλοποιηση αυτη επιλεχθηκε γιατι ηταν η πιο ευκολη λυση που βρηκαμε στο διαδικτυο και αρκετα γρηγορη οπως βγαινει και απο τους χρονους.Οσο αναφορα το compress τιποτα το αξιολογο δεν παρατηρηθηκε.Η υλοποιηση της compress αναγκαστικα εγινε με αναδρομη γιατι δεν γινοταν επανηληπτικα.Καμια αυξηση χρονου.Οσο αναφορα τις search static,dynamic παρατηρηθηκε ενα τεραστιο προβλημα χρονου που ειχε ως αποτελεσμα οι αναζητησεις να καθυστερουν το προγραμμα κατα 90-95%.Γιαυτο τον λογο επρεπε να αλλαξουμε τις search.O τροπος με τον οποιο περναμε τις λεξεις απο την φραση γινοταν με strtok() .Bγαζοντας την strtok() και διαβαζοντας κατευθειαν απο το αρχειο παρατηρησαμε τεραστια διαφορα χρονου της ταξεως των ____ δευτερολεπτων στο small dataset και της ταξεως των ______δευτερολεπτων στο medium dataset.Δεν ξερουμε ακριβως τον λογο για τον οποιο η strtok καθυστερουσε τοσο πολυ το προγραμμα μας.Ισως φταιει ο τροπος με τον οποιο η strtok παιρνει την λεξη απο την υπολοιπη φραση.Για να σιγουρευτουμε οτι εφταιγε η strtok απομονωσαμε ολη την λειτουργια της search και το μονο που εκανε η search ηταν να διαβαζει την φραση λεξη λεξη .Αυτο αργουσε παρα πολυ και ετσι καταληξαμε στο παραπανω συμπερασμα.Οσο αναφορα την top k ξεκινησαμε να σκεφτομαστε διαφορους αλγοριθμους και καταληξαμε αρχικα στην δομη max heap που ειναι ενα δεντρο το οποιο στην ριζα του εχει την max τιμη,και οσο κατεβαινει οι τιμες ειναι ταξινομημενες .Ετσι μπορουμε σχετικα ευκολα να παρουμε τις πρωτες κ τιμες απο το δεντρο αυτο.Αφου το υλοποιησαμε και το αφησαμε για καποιο διαστημα παρατηρησαμε οτι ο χρονος εισαγωγης στο max heap ηταν αρκετα μεγαλος και χρονοβορος σε αντιθεση με τον χρονο αναζητησης.Ομως εμεις επειδη ειχαμε παρα πολλες εισαγωγες και λιγες αναζητησεις αποφασισαμε πως δεν μας κανει η δομη αυτη και γιαυτο την αλλαξαμε.Ετσι δεδομενου οτι ειχαμε παρα πολλες εισαγωγες καταληξαμε σε μια απο τις καλυτερες δομες για εισαγωγη,που δεν ειναι αλλη απο το hash table. 


















