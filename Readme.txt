																							ΑΝΑΠΤΥΞΗ ΛΟΓΙΣΜΙΚΟΥ ΑΣΚΗΣΗ 3η

Ονομα			ΕΠΙΘΕΤΟ			Α.Μ.

ΗΛΙΑΣ			ΒΕΡΓΟΣ			1115201400266
ΚΩΣΤΑΝΤΙΝΟΣ 	ΠΛΕΥΡΗΣ			1115201400162



Προγραμματιστικο Περιβαλλον :LINUX 
Eντολη Μεταγλωτισσης: make
Στο Makefile κανουμε 2 μεταγλωτισσεις,1 για το unit test και μια για το κανονικο προγραμμα.
Για το Unit Testing χρησιμοποιουμε το framework CUnit.Τεσταρουμε στις συναρτησεις static insert,dynamic insert,delete(ΓΙΑ ΤΟ DYNAMIC MOΝΟ ΓΙΑΤΙ ΤΟ ΣΤΑΤΙΚΟ ΔΕΝ ΕΧΕΙ ΔΙΑΓΡΑΦΕΣ), static search,dynamic search,insertion_sort,binary_search.
Για την εγκατασταση της βιβλιοθηκης θα χρειαστει να εκτελεσετε την εντολη :
	sudo apt-get install libcunit1 libcunit1-doc libcunit1-dev
Βεβαια εχουμε συμπεριλαβει και την βιβλιοθηκη μεσα για παν ενδεχομενο.
./exe 		   		-->Unit Test
./ngrams arg1 arg2  -->main programm

																TΕΛΙΚΗ ΑΝΑΦΟΡΑ ΕΡΓΑΣΙΑΣ ΣΤΗΝ ΑΝΑΠΤΥΞΗ ΛΟΓΙΣΜΙΚΟΥ ΓΙΑ ΠΛΗΡΟΦΟΡΙΑΚΑ ΣΥΣΤΗΜΑΤΑ

Tο πρωτο κομματι της ασκησης αφορα την δημιουργια του Τrie καθως και την εισαγωγη ,διαγραφη και αναζητηση σε αυτο.Σε αυτο το κομματι υλοποιησαμε εισαγωγη και αναζητηση με αναδρομικες συναρτησεις ,που ειχε ως αποτελεσμα αυξηση του χρονου.Ακομα, ειχαμε ενα δυναμικο string για την λεξη μεσα σε καθε κομβο και δεν ειχαμε κανενα στατικο σε περιπτωση που το string ηταν μικρο.Και αυτο ειχε ως αποτελεσμα μια πολυ μικρη αυξηση του χρονου.Κατι ακομα που μας απασχολησε ηταν ποια συναρτηση αναζητησης θα χρησιμοποιουσαμε.Αρχικα δοκιμασαμε την σειριακη αναζητηση ομως απο πλευρας χρονου ηταν πολυ σπαταλη λογω της πολυπλοκοτητας της .Στην συνεχεια δοκιμασαμε την δυαδικη αναζητηση .Ο χρονος ηταν καλος ,οχι ομως ικανοποιητικος.Γιαυτο σκεφτηκαμε να χρησιμοποιησουμε την binary insertion sort που φαινοταν να ηταν καλυτερη.Ομως δεν ειδαμε καποια διαφορα ,ισα ισα που ειχαμε μια μικρη αυξηση στον χρονο,οποτε και την αλλαξαμε και καταληξαμε στην binary search.Παρομοια διλληματα ειχαμε και με την ταξινομηση μιας και εδω ειχαμε πολλες επιλογες.Ξεκινησαμε με φυσαλιδα ,ο χρονος ηταν κατα μια εννοια καλος .Δοκιμασαμε διαφορες ταξινομησεις χωρις καποια αξιολογη διαφορα.Γιαυτο  αφησαμε την φυσαλιδα για λιγο.Ομως στο τελος θελωντας να βελτιωσουμε αρκετα τον χρονο μας κατι επρεπε να αλλαξουμε,και γιαυτο σκεφτηκαμε την insertion sort που ηταν οτι καλυτερο για πινακες που ειναι σχεδον ταξινομημενοι οπως στην περιπτωση μας.Και ετσι αφησαμε την insertion sort.





Καποιοι ενδεικτικοι χρονοι για τα παραπανω παρουσιαζονται στον παρακατω πινακα:

	 		
	  		
------------|-------|-------|-------|-------|-------|
   XΡΟΝΟΙ	|26.983s|30.583s|45.319s|39.832s|		|
------------|-------|-------|-------|-------|-------|
αναδρομικες |		|		|		|		|		|
συναρτησεις |	+	|	+	|	+	|	+	|		|
			|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|
			|		|		|		|		|		|
δυναμικα 	|	+	|	+	|	+	|	+	|		|
strings		|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|
φυσαλιδα	|		|	+	|	+	|		|		|
------------|-------|-------|-------|-------|-------|
σειριακη 	|		|		|		|		|		|
αναζητηση	|		|		|	+	|	+	|		|
			|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|
insertion	|		|		|		|		|		|
sort		|	+	|		|		|	+	|		|
			|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|
binary 		|		|		|		|		|		|
search		|	+	|	+	|		|		|		|
			|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|





Το δευτερο μερος ξεκινησε κανοντας τις αλλαγες που μας ειπωθηκαν.Δηλαδη αλλαξαμε τις λεξεις μεσα στα Trie nodes να ειναι στατικα αν το μηκος της λεξης ειναι μικροτερο απο 50 και δυναμικο αν ειναι μεγαλυτερο του 50.Οπως ειπαμε παραπανω δεν παρατηρηθηκε καποια αισθητη αλλαγη .Το ιδιο συνεβη και με την αλλαγη των συναρτησεων απο αναδρομικες σε επαναληπτικες.Η διαφορα σε χρονο και μνημη ηταν σχεδον μηδαμινη.Κατι αλλο που μας ειπωθηκε ηταν να αλλαξουμε την insertion sort και να χρησιμοποιησουμε memmove για καλυτερη προσπελαση της μνημης και επομενως καλυτερο χρονο.Το καναμε και το αποτελεσμα ηταν καποια μικρη διαφορα της ταξεως των _____ δευτερολεπτων στo small dataset και ____ δευτερολεπτων στο medium dataset.Aφου καναμε τις απαραιτητες αλλαγες προχωρησαμε στην υλοποιηση του 2ου μερους της ασκησης.Σε αυτο το μερος ξεκινησαμε να φτιαχνουμε το bloom filter το οποιο βασιζεται πανω σε ενα char* του οποιου καθε θεση περιεχει 8 bits μιας και char= 1byte = 8 bits.Αρχικοποιουμε τον πινακα αυτο με 0 κανοντας την πραξη bitwise AND (&0) με καθε θεση του πινακα.Στην συνεχεια οταν ειναι να ελενξουμε αν υπαρχει μεσα στον πινακα ενα ngram ελενχουμε την τιμη της θεσης του πινακα που προκυπτει απο την hash function με την θεση του bit που προκυπτει και αυτη απο την hash function και κανουμε τον ελενχο ((array[position]>>bit_position)&1).Aν βγει 0 η συνθηκη αυτη τοτε σημαινει οτι δεν υπαρχει αλλιως υπαρχει αν βγει 1.Η συνθηκη αυτη προκυπτει και απο τον τροπο με τον οποιο βαζουμε ενα στοιχειο μεσα στον πινακα.Αυτο γινεται παιρνωντας το 1 που θελουμε να βαλουμε στην θεση του bit ολισθαινοντας το κατα bit_position θεσεις αριστερα.Ετσι ο πινακα παιρνει μια τιμη που ειναι απο (-128,128) και συμβολιζει την λεξη που μπηκε.Αυτα οσο αναφορα την υλοποιηση του bloom filter.Η υλοποιηση αυτη επιλεχθηκε γιατι ηταν η πιο ευκολη λυση που βρηκαμε στο διαδικτυο και αρκετα γρηγορη οπως βγαινει και απο τους χρονους.Οσο αναφορα το compress τιποτα το αξιολογο δεν παρατηρηθηκε.Η υλοποιηση της compress αναγκαστικα εγινε με αναδρομη γιατι δεν γινοταν επανηληπτικα.Καμια αυξηση χρονου.Οσο αναφορα τις search static,dynamic παρατηρηθηκε ενα τεραστιο προβλημα χρονου που ειχε ως αποτελεσμα οι αναζητησεις να καθυστερουν το προγραμμα κατα 90-95%.Γιαυτο τον λογο επρεπε να αλλαξουμε τις search.O τροπος με τον οποιο περναμε τις λεξεις απο την φραση γινοταν με strtok() .Bγαζοντας την strtok() και διαβαζοντας κατευθειαν απο το αρχειο παρατηρησαμε τεραστια διαφορα χρονου της ταξεως των ____ δευτερολεπτων στο small dataset και της ταξεως των ______δευτερολεπτων στο medium dataset.Δεν ξερουμε ακριβως τον λογο για τον οποιο η strtok καθυστερουσε τοσο πολυ το προγραμμα μας.Ισως φταιει ο τροπος με τον οποιο η strtok παιρνει την λεξη απο την υπολοιπη φραση.Για να σιγουρευτουμε οτι εφταιγε η strtok απομονωσαμε ολη την λειτουργια της search και το μονο που εκανε η search ηταν να διαβαζει την φραση λεξη λεξη .Αυτο αργουσε παρα πολυ και ετσι καταληξαμε στο παραπανω συμπερασμα.Οσο αναφορα την top k ξεκινησαμε να σκεφτομαστε διαφορους αλγοριθμους και καταληξαμε αρχικα στην δομη max heap που ειναι ενα δεντρο το οποιο στην ριζα του εχει την max τιμη,και οσο κατεβαινει οι τιμες ειναι ταξινομημενες .Ετσι μπορουμε σχετικα ευκολα να παρουμε τις πρωτες κ τιμες απο το δεντρο αυτο.Αφου το υλοποιησαμε και το αφησαμε για καποιο διαστημα παρατηρησαμε οτι ο χρονος εισαγωγης στο max heap ηταν αρκετα μεγαλος και χρονοβορος σε αντιθεση με τον χρονο αναζητησης.Ομως εμεις επειδη ειχαμε παρα πολλες εισαγωγες και λιγες αναζητησεις αποφασισαμε πως δεν μας κανει η δομη αυτη και γιαυτο την αλλαξαμε.Ετσι δεδομενου οτι ειχαμε παρα πολλες εισαγωγες καταληξαμε σε μια απο τις καλυτερες δομες για εισαγωγη,που δεν ειναι αλλη απο το hash table, με linear hashing , εδώ ο χρονος εισαγωγης ειναι σχεδον Ο(1) και ο χρόνος εύρεσης είναι περιπου Ο(n) κατι που ειναι παρα πολυ θετικο αφου δεν θελουμε να καθυστερει πολυ στην εισαγωγη της λέξης στο hash table, για το topk, αφου σε ενα search μπορουν να υπαρχουν πολλα ngrams και οι εισαγωγες τους στο topk να ειναι πολλες. Αν χρησιμοποιουσαμε MaxHeap η MinHeap για την δομη μας, το topk, τοτε καθε εισαγωγη θα κοστιζε περιπου Ο(logn), κατι ομως που αυξανει τον χρονο παρα πολυ, περα απο το γεγονος οτι η ευρεση των topk ειναι πολυ γρηγορη, γιατι οι αναζητησεις των topk, σε σχεση με τις ερωτησεις, ειναι ελαχιστες.


small static
------------|-------|-------|-------|-------|-------|-------| 
   XΡΟΝΟΙ	|2.046s	|2.152s	|4.049s	|4.441s |2.085s	|1m20s  | 
------------|-------|-------|-------|-------|-------|-------|
επαναληπτι- |		|		|		|		|		|		|
κες		    |	+	|	+	|	+	|	+	|	+	|	+	|
συναρτησεις |		|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|-------|
στατικα και	|		|		|		|		|		|		|
δυναμικα 	|	+	|	+	|	+	|	+	|	+	|	+	|
strings		|		|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|-------|
hash table  |	+	|	+	|		|		|	+	|	+	|
	top		|		|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|-------|
  max heap	|		|		|		|		|		|		|
	top		|		|		|	+	|	+	|		|		|
			|		|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|-------|
insertion	|		|		|		|		|		|		|
sort		|	+	|		|		|	+	|	+	|	+	|
memmove		|		|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|-------|
insertion	|		|		|		|		|		|		|
with hash	|	+	|	+	|	+	|	+	|	+	|	+	|
table		|		|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|-------|
			|		|		|		|		|		|		|
compress	|	+	|	+	|	+	|	+	|		|	+	|
			|		|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|-------|
			|		|		|		|		|		|		|
strtok		|		|		|		|		|		|	+	|
			|		|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|-------|


small dynamic
------------|-------|-------|-------|-------|-------| 
   XΡΟΝΟΙ	|1.439s	|1.502s |3.074s	|3.112s	|50.321s|      
------------|-------|-------|-------|-------|-------|
επαναληπτι- |		|		|		|		|		|
κες		    |	+	|	+	|	+	|	+	|	+	|
συναρτησεις |		|		|		|		|		|
------------|-------|-------|-------|-------|-------|
στατικα και	|		|		|		|		|		|
δυναμικα 	|	+	|	+	|	+	|	+	|	+	|
strings		|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|
hash table  |	+	|	+	|		|		|	+	|
	top		|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|
  max heap	|		|		|		|		|		|
	top		|		|		|	+	|	+	|		|
			|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|
insertion	|		|		|		|		|		|
sort		|	+	|		|	+	|		|	+	|
memmove		|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|
insertion	|		|		|		|		|		|
with hash	|	+	|	+	|	+	|	+	|	+	|
table		|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|
			|		|		|		|		|		|
strtok		|		|		|		|		|	+	|
			|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|


medium static
------------|-------|-------|-------|-------|-------|-------| 
   XΡΟΝΟΙ	|1m4.69s|1m7.01s|1m55.3s|1m54.9s|1m53.8s|35m.20s|
------------|-------|-------|-------|-------|-------|-------|
επαναληπτι- |		|		|		|		|		|		|
κες		    |	+	|	+	|	+	|	+	|	+	|	+	|
συναρτησεις |		|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|-------|
στατικα και	|		|		|		|		|		|		|
δυναμικα 	|	+	|	+	|	+	|	+	|	+	|	+	|
strings		|		|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|-------|
hash table  |	+	|	+	|		|		|	+	|	+	|
	top		|		|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|-------|
  max heap	|		|		|		|		|		|		|
	top		|		|		|	+	|	+	|		|		|
			|		|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|-------|
insertion	|		|		|		|		|		|		|
sort		|	+	|		|		|	+	|	+	|	+	|
memmove		|		|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|-------|
insertion	|		|		|		|		|		|		|
with hash	|	+	|	+	|	+	|	+	|	+	|	+	|
table		|		|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|-------|
			|		|		|		|		|		|		|
compress	|	+	|	+	|	+	|	+	|		|	+	|
			|		|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|-------|
			|		|		|		|		|		|		|
strtok		|		|		|		|		|		|	+	|
			|		|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|-------|



medium dynamic
------------|-------|-------|-------|-------|-------| 
   XΡΟΝΟΙ	|47.798s|48.142s|1m48s	|1m49s  |33m1s	|      
------------|-------|-------|-------|-------|-------|
επαναληπτι- |		|		|		|		|		|
κες		    |	+	|	+	|	+	|	+	|	+	|
συναρτησεις |		|		|		|		|		|
------------|-------|-------|-------|-------|-------|
στατικα και	|		|		|		|		|		|
δυναμικα 	|	+	|	+	|	+	|	+	|	+	|
strings		|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|
hash table  |	+	|	+	|		|		|	+	|
	top		|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|
  max heap	|		|		|		|		|		|
	top		|		|		|	+	|	+	|		|
			|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|
insertion	|		|		|		|		|		|
sort		|	+	|		|	+	|		|	+	|
memmove		|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|
insertion	|		|		|		|		|		|
with hash	|	+	|	+	|	+	|	+	|	+	|
table		|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|
			|		|		|		|		|		|
strtok		|		|		|		|		|	+	|
			|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|


Το τριτο μερος της εργασιας ξεκινησε αλλαζοντας παλι τις συναρτησεις των search, επειδη οι συναρτησεις αναζητησης ειχαν σαν ορισμα ενα FILE* εβρισκαν απο μονες τους το κειμενο, το οποιο επρεπε να αναζητησουν, τωρα ομως αυτο το κειμενο επρεπε να αποθηκευτει καπου, αφου επρεπε να το βαλουμε σε ενα buffer, για να το χειριστει ο JobScheduler και μετα να το δωσουμε στις συναρτησεις αναζητησης, καθως δουλευουμε με νηματα. Έτσι μετατρεψαμε παλι τις συναρτησεις αναζητησης, ωστε να δεχονται κατευθειαν το string και οχι να το βρισκουν απο το αρχειο. Οι χρονοι παρεμειναν αρκετα κοντα(θα συμπληροσουμε χρονους ___________________ ), με τους χρονους των συναρτησεων πριν την μετατροπη τους.
	Στη συνεχεια ξεκινησαμε την υλοποηση της τριτη ασκησης, η οποια ειχε ως σκοπο την παραλληλοποιηση, ωστε να πετυχουμε καλυτερους χρονους. Αρχικα υλοποιησαμε τον JobScheduler με την βιβλιοθηκη Job_Scheduler η οποια περιλαμβανει τις παρακατω συναρτησεις:

1) Job_Scheduler* initialize_scheduler(int,hash_trie*,hash_keeper**,int,thread_param **);
2) void *Worker(void* i);
3) void submit_job(Job_Scheduler* schedule,Job* j,int id,int current_version);
4) void execute_all_jobs(Job_Scheduler*,thread_param *,char **);
5) void wait_all_tasks_finish(Job_Scheduler* schedule);
6) void reset_queue(Queue *);
7) void execute_job(thread_param *,int);
8) void delete_threads(Job_Scheduler **,thread_param **);



1) Job_Scheduler* initialize_scheduler(int,hash_trie*,hash_keeper**,int,thread_param **):
	Αυτη η συναρτηση αρχικοποιεί τον JobScheduler, δηλαδή αρχικοποιεί την δομή του, οπως επισης και την ουρα, στην οποια εισερχονται τα jobs.
	Επισης αρχικοποιουνται και τα threads.



2) void *Worker(void* i)
	Αυτη ειναι η συναρτηση με την οποια καλουνται τα threads. Τα οποια ακολουθουν το μοντελο του παραγωγου-καταναλωτη. Σε αυτην την ασκηση εχουμε ενα παραγωγο και πολλαπλους        καταναλωτες τα οποια ειναι τα threads μας. Δηλαδη, με μια ριπη ο παραγωγος βαζει μεσα στην ουρα τα job που πρεπει να διεκπεραιωσουν οι καταναλωτες. Έπειτα τα treads στελνουν σημα στο wait_all_tasks_finish να ξεκινησει για να συνεχισει η main και να φερει την επομενη ριπη οταν ερθει η execute_job δινει σημα στα threads να ξεκινησουν για να εκτελεσουν την ριπη.



3)void submit_job(Job_Scheduler* schedule,Job* j,int id,int current_version)
 	Καθε ερωτηση που ερχεται, προστεθεται στον buffer του JobScheduler, μαζι με τις απαραιτητες πληροφοριες για να την εκτελεσουν τα threads αργοτερα.

4) void execute_all_jobs(Job_Scheduler*,thread_param *,char **)
	Οταν εισελθουν ολες οι ερωτησεις στον buffer, η main καλει αυτην την συναρτηση, η οποια στελνει σημα στα threads να ξεκινησουν



5) void wait_all_tasks_finish(Job_Scheduler* schedule)
	Λαμβάνει σημα οταν τελειωσουν τις εργασιες τα threads, και συνεχιζει η main για να εισαγει την επομενη ριπη στον buffer του JobScheduler.

6) void reset_queue(Queue *)
	Μετα απο κάθε ριπη, αυτη η συναρτηση κανει reset τους δεικτες του buffer, για την επομενη ριπη.



7) void execute_job(thread_param *,int)
	Βοηθητικη συναρτηση για τα threads για να εκτελουν τις εργασιες τους.



8) void delete_threads(Job_Scheduler **,thread_param **)
	Καλειτε στο τελος για την απελευθερωση της μνημη που κατέλαβε ο JobScheduler και τα Threads.


 
------------|-------|-------|-------|-------|-------|
   XΡΟΝΟΙ	|30.4sec|		|		|		|		|
------------|-------|-------|-------|-------|-------|
αναδρομικες |		|		|		|		|		|
συναρτησεις |	+	|	+	|	+	|	+	|		|
			|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|
			|		|		|		|		|		|
δυναμικα 	|	+	|	+	|	+	|	+	|		|
strings		|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|
φυσαλιδα	|		|	+	|	+	|		|		|
------------|-------|-------|-------|-------|-------|
σειριακη 	|		|		|		|		|		|
αναζητηση	|		|		|	+	|	+	|		|
			|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|
insertion	|		|		|		|		|		|
sort		|	+	|		|		|	+	|		|
			|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|
binary 		|		|		|		|		|		|
search		|	+	|	+	|		|		|		|
			|		|		|		|		|		|
------------|-------|-------|-------|-------|-------|














